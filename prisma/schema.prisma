generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// -----------------------------------------------------------------------------
// User Domain
// -----------------------------------------------------------------------------

enum UserRole {
  CHILD
  VOLUNTEER
  COLLEGE_ADMIN
  PLATFORM_ADMIN
}

enum UserStatus {
  ACTIVE    // Normal
  INACTIVE  // Not activated (e.g. pre-created)
  SUSPENDED // Banned
}

enum WechatProvider {
  MINI_PROGRAM
}

model User {
  id           Int        @id @default(autoincrement())
  username     String     @unique // Child: generated name, Volunteer: studentId/email
  passwordHash String
  role         UserRole
  status       UserStatus @default(INACTIVE)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Relations (Only one profile will be non-null based on role)
  childProfile     ChildProfile?
  volunteerProfile VolunteerProfile?
  adminProfile     AdminProfile?
  
  // Audit
  auditLogs        AuditLog[]        @relation("OperatorLogs")

  // Interactions
  videoLikes        VideoLike[]       @relation("UserVideoLikes")
  videoFavorites    VideoFavorite[]   @relation("UserVideoFavorites")
  videoComments     VideoComment[]    @relation("UserVideoComments")
  videoWatchLogs    VideoWatchLog[]   @relation("UserVideoWatchLogs")
  liveMessages      LiveMessage[]     @relation("UserLiveMessages")

  // WeChat bindings
  wechatAccounts    WechatAccount[]
}

model WechatAccount {
  id        Int           @id @default(autoincrement())
  provider  WechatProvider
  appId     String
  openId    String
  unionId   String?

  userId    Int
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@unique([provider, appId, openId])
  @@index([userId])
}

enum Gender {
  MALE
  FEMALE
  UNKNOWN
}

model ChildProfile {
  userId   Int    @id
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  realName String
  school   String
  grade    String
  gender   Gender @default(UNKNOWN)
}

enum VolunteerStatus {
  IN_SCHOOL
  GRADUATED
  SUSPENDED
}

model VolunteerProfile {
  userId    Int             @id
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  realName  String
  studentId String // University ID
  collegeId Int
  college   College         @relation(fields: [collegeId], references: [id])
  phone     String?
  status    VolunteerStatus @default(IN_SCHOOL)

  // Content Relations
  videos    Video[]
  liveRooms LiveRoom[]
}

model AdminProfile {
  userId    Int      @id
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  realName  String
  collegeId Int? // Null for Platform Admin
  college   College? @relation(fields: [collegeId], references: [id])
}

model College {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  volunteers  VolunteerProfile[]
  admins      AdminProfile[]
  videos      Video[]
  liveRooms   LiveRoom[]
}

// -----------------------------------------------------------------------------
// Content Domain (Video)
// -----------------------------------------------------------------------------

enum VideoStatus {
  DRAFT     // Private, editable
  REVIEW    // Submitted for audit
  APPROVED  // Passed review, waiting volunteer to publish
  PUBLISHED // Public for children
  REJECTED  // Rejected by admin
  OFFLINE   // Forced offline
}

model Video {
  id           Int         @id @default(autoincrement())
  title        String
  intro        String?     @db.Text
  url          String // OSS Url
  coverUrl     String?
  duration     Int? // Seconds
  gradeRange   String? // e.g. "1-3"
  subjectTag   String? // e.g. "Math"
  
  status       VideoStatus @default(DRAFT)
  rejectReason String?

  reviewedBy   Int?
  reviewedAt   DateTime?

  publishedBy  Int?
  publishedAt  DateTime?

  offlineBy    Int?
  offlineAt    DateTime?
  offlineReason String?
  
  uploaderId   Int
  uploader     VolunteerProfile @relation(fields: [uploaderId], references: [userId])
  collegeId    Int
  college      College          @relation(fields: [collegeId], references: [id])
  
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  // 1:1 Relation for frequently updated stats to reduce lock contention on main table
  metrics      VideoMetrics?

  // Interactions
  likes        VideoLike[]       @relation("VideoLikes")
  favorites    VideoFavorite[]   @relation("VideoFavorites")
  comments     VideoComment[]    @relation("VideoComments")
  watchLogs    VideoWatchLog[]   @relation("VideoWatchLogs")

  // Replay source (one video can be bound as replay for multiple lives)
  replayLives  LiveRoom[]        @relation("LiveReplayVideo")
}

model VideoMetrics {
  videoId   Int   @id
  video     Video @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  playCount Int   @default(0)
  likeCount Int   @default(0)
  favCount  Int   @default(0)
}

enum CommentStatus {
  PENDING
  APPROVED
  REJECTED
}

model VideoLike {
  videoId   Int
  userId    Int
  video     Video @relation("VideoLikes", fields: [videoId], references: [id], onDelete: Cascade)
  user      User  @relation("UserVideoLikes", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@id([videoId, userId])
}

model VideoFavorite {
  videoId   Int
  userId    Int
  video     Video @relation("VideoFavorites", fields: [videoId], references: [id], onDelete: Cascade)
  user      User  @relation("UserVideoFavorites", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@id([videoId, userId])
}

model VideoComment {
  id          Int          @id @default(autoincrement())
  videoId     Int
  authorId    Int
  content     String       @db.Text
  status      CommentStatus @default(PENDING)
  rejectReason String?
  reviewedBy  Int?
  reviewedAt  DateTime?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  video       Video @relation("VideoComments", fields: [videoId], references: [id], onDelete: Cascade)
  author      User  @relation("UserVideoComments", fields: [authorId], references: [id], onDelete: Cascade)
}

model VideoWatchLog {
  id              Int      @id @default(autoincrement())
  videoId         Int
  userId          Int
  lastPositionSec Int      @default(0)
  watchedSeconds  Int      @default(0)
  completed       Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  video           Video @relation("VideoWatchLogs", fields: [videoId], references: [id], onDelete: Cascade)
  user            User  @relation("UserVideoWatchLogs", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([videoId, userId])
}

// -----------------------------------------------------------------------------
// Live Domain
// -----------------------------------------------------------------------------

enum LiveStatus {
  DRAFT
  REVIEW
  PASSED    // Approved, waiting for publish
  PUBLISHED // Visible to children, waiting for start
  REJECTED
  LIVING    // In progress
  FINISHED  // Ended
  OFFLINE   // Forced stop
}

model LiveRoom {
  id            Int      @id @default(autoincrement())
  title         String
  intro         String?
  
  planStartTime DateTime
  planEndTime   DateTime
  actualStart   DateTime?
  actualEnd     DateTime?
  
  status        LiveStatus @default(DRAFT)
  rejectReason  String?

  reviewedBy    Int?
  reviewedAt    DateTime?

  publishedBy   Int?
  publishedAt   DateTime?

  offlineBy     Int?
  offlineAt     DateTime?
  offlineReason String?
  
  pushUrl       String?  @db.Text // Private for anchor
  pullUrl       String?  @db.Text // Public for audience

  // Replay binding (optional): after live ends, bind a recorded replay video
  replayVideoId Int?
  replayVideo   Video?   @relation("LiveReplayVideo", fields: [replayVideoId], references: [id])

  messages      LiveMessage[] @relation("LiveRoomMessages")
  
  anchorId      Int
  anchor        VolunteerProfile @relation(fields: [anchorId], references: [userId])
  collegeId     Int
  college       College          @relation(fields: [collegeId], references: [id])

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

enum LiveMessageType {
  CHAT
  QA
}

model LiveMessage {
  id        Int            @id @default(autoincrement())
  liveId    Int
  senderId  Int
  type      LiveMessageType @default(CHAT)
  content   String         @db.Text
  createdAt DateTime       @default(now())

  live      LiveRoom @relation("LiveRoomMessages", fields: [liveId], references: [id], onDelete: Cascade)
  sender    User     @relation("UserLiveMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([liveId, id])
}

// -----------------------------------------------------------------------------
// Interaction & System Domain
// -----------------------------------------------------------------------------

enum AuditAction {
  LOGIN
  CREATE
  UPDATE
  DELETE
  REVIEW_PASS
  REVIEW_REJECT
  PUBLISH
  OFFLINE
}

model AuditLog {
  id         Int         @id @default(autoincrement())
  operatorId Int
  operator   User        @relation("OperatorLogs", fields: [operatorId], references: [id])
  
  action     AuditAction
  targetId   String?     // ID of the object being manipulated
  targetType String?     // e.g. "Video", "User"
  detail     String?     @db.Text
  clientIp   String?
  
  createdAt  DateTime    @default(now())
}

// -----------------------------------------------------------------------------
// Content Moderation Domain (Sensitive words + feature switches)
// -----------------------------------------------------------------------------

enum ModerationAction {
  REJECT
  MASK
}

model ContentPolicy {
  id               Int              @id @default(autoincrement())
  commentsEnabled  Boolean          @default(true)
  liveChatEnabled  Boolean          @default(true)
  moderationAction ModerationAction @default(REJECT)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
}

model SensitiveWord {
  id        Int      @id @default(autoincrement())
  word      String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

